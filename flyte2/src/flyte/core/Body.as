package flyte.core{	import flash.display.Sprite;		import flyte.cogs.CollisionCog;	import flyte.cogs.DirectionCog;	import flyte.cogs.GravityCog;	import flyte.events.ActionEvent;	import flyte.events.CollisionEvent;	import flyte.events.GameEvent;		public class Body extends Base	{		public var gravity:GravityCog		public var collision:CollisionCog		public var direction:DirectionCog		public var velocityX:Number = 0		public var velocityY:Number = 0		public var velocityDamping:Number=0.85		public var ground:Static		public var enableMovement:Boolean = true		private var jumpVelocity:Number=0		private var _jumping:Boolean=false		public function Body()		{			direction = new DirectionCog(this)			gravity = new GravityCog(this)			collision = new CollisionCog(this)			collision.addEventListener(CollisionEvent.COLLIDE,onCollision)			collision.addEventListener(CollisionEvent.END_COLLIDE,onEndCollision)			event.onLoopDo(update)		}				private function onCollision(e:CollisionEvent):void		{		}				private function onEndCollision(e:CollisionEvent):void		{		}				public function get onGround():Boolean		{			return ground != null		}				private function update(e:GameEvent):void		{						if(((this.velocityX > 0 && ! collision.right) || (this.velocityX < 0 && ! collision.left)) && this.enableMovement)			{				this.x += Math.cos(d2r(this.rotation)) * velocityX				this.y += Math.sin(d2r(this.rotation)) * velocityX			}else{				this.velocityX = 0			}			velocityX *= velocityDamping			collision.test()			if(onGround)			{				this.x += ground.displacement.point.x * 2				this.y += ground.displacement.point.y * 2			}						if(this.y > world.lowerBoundary)			{				event.fire(new ActionEvent(ActionEvent.LEAVE_WORLD))			}			if(!this.onGround)			{				this.rotation += (0 - rotation) / 5			}		}				public function doJump(height:Number):void		{			if(_jumping)			{				jumpVelocity += 0			}else{				_jumping = true				jumpVelocity = height				event.onLoopDo(whileJumping)				this.gravity.disable()			}		}				private function whileJumping(e:GameEvent):void		{			if(!collision.top)			{				this.y -= jumpVelocity			}else{				gravity.addVelocity(jumpVelocity)				endJump()			}			jumpVelocity -= this.world.gravity			if(jumpVelocity < 0.1)			{				endJump()			}		}				private function endJump():void		{			event.onLoopDont(whileJumping)			gravity.enable()			jumpVelocity = 0			_jumping = false		}				public function get jumping():Boolean		{			return _jumping		}						public function landOn(s:Static):void		{			this.ground = s			gravity.onGround()			collision.bottom = true		}				public function rebound(multiplier:Number=1,type:String="X"):void		{			type = type.toLowerCase()			if(type == "x"){				this.velocityX *= -1 * multiplier			}else{				if(this.onGround)				{					this.doJump(multiplier)				}else{					this.gravity.reboundTop(multiplier)				}			}		}	}}