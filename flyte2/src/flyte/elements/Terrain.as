package flyte.elements{	import flash.geom.Point;	import flash.geom.Rectangle;		import flyte.core.Base;	import flyte.core.Body;	import flyte.core.Static;	public class Terrain extends Static	{				public override function collidesWith(t:Base):Boolean		{			var bounds:Rectangle = t.getBounds(stage)			var mp:Point = new Point(bounds.left + (bounds.width/2),bounds.bottom)			return this.hitTestPoint(mp.x,mp.y,true)		}						public override function displace(t:Body):Vector.<Boolean>		{			var v:Vector.<Boolean> = new Vector.<Boolean>(4)			v[0] = v[1] = v[2] = v[3] = false						var bounds:Rectangle = t.getBounds(stage)			//trace(bounds.top)			var left:Point = new Point(bounds.left,bounds.bottom)			var right:Point = new Point(bounds.right,bounds.bottom)			var middle:Point = new Point((bounds.left + bounds.right) / 2,bounds.bottom)			//trace(left.x,left.y)			for(var i:uint=0;i<1000;i++)			{				if(this.hitTestPoint(left.x,left.y,true))				{					left.y --				}else{					break				}			}						for(var j:uint=0;j<1000;j++)			{				if(this.hitTestPoint(right.x,right.y,true))				{					right.y --				}else{					break				}			}									var theta:Number = Math.atan(				(right.y - left.y) / (right.x - left.x)			)						t.rotation = theta * (180 / Math.PI)						var mp:Point = new Point(bounds.left + (bounds.width/2),bounds.bottom)			for(var k:uint=0;k<1000;k++){				if(this.hitTestPoint(mp.x,mp.y,true))				{					mp.y --				}else{					break				}			}			t.y -= k - 5											v[3] = true			return v				}	}}